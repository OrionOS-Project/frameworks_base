page.title=Rendering Problems Checklist
page.tags=render
page.article=true
@jd:body

<p>The following checklist summarizes common rendering problems and solutions.
For each problem, learn how users are affected, how to diagnose, and how to
approach fixing it. Use the linked resources for details on the suggested solutions.</p>

<!----------------------------->

  <h2>Excessive Overdraw</h2>

  <p><b>What the user sees:</b><br>
  The most likely symptom is a generic general slowness of screen
  rendering, as well as stuttering animations.</p>

  <p><b>Use this tool:</b><br>
  <a href="{@docRoot}tools/performance/debug-gpu-overdraw/index.html">
  Debug GPU Overdraw</a></p>

  <p><b>What you see:</b><br>
  Red-colored views indicate multiple layers of unnecessary drawing.</p>

  <p><b>Problem:</b><br>
  Your app redraws the same pixels multiple times, resulting in
  overdraw.</p>

  <p><b>Solution:</b><br>
  If you are drawing pixels on the screen that the user never sees, you might
  be able to improve drawing performance by removing unnecessary backgrounds, reorganizing views,
  and applying clipping techniques to custom views.</p>

  <p><b>Optimize your app:</b><br>
  <a href="{@docRoot}training/app/rendering/overdraw.html">Reduce Overdraw</a>,
  <a href="{@docRoot}training/app/rendering/hierarchies.html">Simplifying View Hierarchies</a>,
  and
  <a href="https://www.youtube.com/watch?v=vkTn3Ule4Ps">Apply Clipping</a>.</p>

<!----------------------------->

  <h2>View Hierarchies that are too complex</h2>

  <p><b>What the user sees:</b><br>
  The most likely symptom is a generic general slowness of the app,
  especially when rendering complex views to the screen.</p>

  <p><b>Use this tool:</b><br>
  <a href="{@docRoot}tools/performance/hierarchy-viewer/index.html">Hierarchy Viewer</a></p>

  <p><b>What you see:</b><br>
  A view hierarchy that is deeper than wide, with a lot of nesting. When
  you profile your view hierarchy, there are red dots in leaf nodes.
  See <a href="{@docRoot}tools/performance/hierarchy-viewer/profiling.html">
      Profiling with Hierarchy Viewer</a>.</p>

  <p><b>Problem:</b><br>
  The more complex and deep your view hierarchy, the more likely it is that a
  simple change to a view can trigger multiple passes through large parts of this hierarchy to
  recalculate the sizes, positions, and layout of affected views.</p>

  <p><b>Solution:</b><br>
  Flatten and simplify your view hierarchies. Try different layouts. Combine
  views.</p>

  <p><b>Optimize your app:</b><br>
  <a href="{@docRoot}training/app/rendering/hierarchies.html">
      Simplify Complex View Hierarchies</a>.</p>


<!----------------------------->

  <h2>Too many Invalidations</h2

  <p><b>What the user sees:</b><br>
  Slow response to user-initiated actions. Sluggish scrolling.</p>

  <p><b>Use these tools:</b><br>
  On your mobile device, in Developer Options, turn on
  <a href="{@docRoot}tools/performance/profile-gpu-rendering/index.html">Profile GPU Rendering</a>
  and GPU View Updates.</p>

  <p><b>What you see:</b><br>
  In Profile GPU Rendering, for bars that cross the 16 millisecond threshold, the
  blue updated segment in particular may be large. The M release of Android adds additional color
  segments, and the Measure/Layout segment may also be larger than expected.</p>

  <p>In GPU View Updates, portions of the screen will flicker wildly in response to user
  actions:</p>

  <ul>
    <li>One portion of the screen continues to flicker long after it has stopped changing visually
    for the user.</li>

    <li>Large portions of the screen flicker, even though only a small part is changing
    visually.</li>
  </ul>

  <b>Problem:</b><br>
  <p>Every time a view changes, the display lists are invalidated and have to be
  recreated and executed.</p>

  <b>Solution:</b><br>
  <p>While it is impossible to avoid invalidations, minimizing how often they
  happen, and how many views are affected, can improve your app's
  performance.</p>

  <b>Optimize your app:</b><br>
  <p>Minimize view invalidations. See
  <a href="https://www.youtube.com/watch?v=we6poP0kw6E">Views, Invalidations, and
  Performance</a>
  and <a href="https://www.youtube.com/watch?v=dB3_vgS-Uqo">Double Layout Taxation</a>.</p>


<!----------------------------->

  <h2>Multiple Layout Passes</h2>

  <p><b>What the user sees:</b><br>
  Slow response to user-initiated actions. Sluggish scrolling.</p>

  <p><b>Use these tools:</b><br>
  <a href="{@docRoot}tools/performance/hierarchy-viewer/index.html">Hierarchy Viewer</a>.
  On your mobile device, in Developer
  Options, turn on
  <a href="{@docRoot}tools/performance/profile-gpu-rendering/index.html">Profile GPU Rendering</a>
  and GPU View Updates.</p>

  <p><b>What you see:</b><br>
  In Profile GPU Rendering, for bars that cross the 16 millisecond threshold, the
  blue segment in particular may be large. In GPU View Updates, large portions of the whole screen
  will flicker wildly in response to user actions. In Hierarchy Viewer, look for red dots in the
  measure and layout phases, especially on leaf nodes.</p>

  <p><b>Problem:</b><br>
  Changing the position or size of a view can trigger a cascade of calculations
  throughout your view hierarchy to adjust neighboring and parent views.</p>

  <p><b>Solution</b><br>
  You might be able to improve rendering performance by rearranging or
  simplifying your view hierarchy, or by using different layout containers.</p>

  <p><b>Optimize your app:</b><br>
  <href="{@docRoot}training/app/rendering/hierarchies.html">
      Simplify Complex View Hierarchies</a>
  and minimize view invalidations.
  See <a href=
  "https://www.youtube.com/watch?v=we6poP0kw6E">Views, Invalidations, and Performance</a>
  and <a href="https://www.youtube.com/watch?v=dB3_vgS-Uqo">Double Layout Taxation</a>.</p>


<!----------------------------->

  <h2>Alpha Blending</h2>

  <p><b>What the user sees:</b><br>
  App slows down whenever views and animations use alpha
  rendering.</p>

  <p><b>Use this tool:</b><br>
  <a href="{@docRoot}tools/performance/profile-gpu-rendering/index.html">Profile GPU Rendering</a>.
  Also, in Developer options, turn on
  Show Hardware Layers Updates. The screen will flash green for every hardware layer update. Note
  that for pre-M (API level 22 and below), you have to use hardware layers explicitly (e.g.
  mView.animate().alpha(0).withLayer().start()), while for API levels 23 and above, the system does
  this for you automatically.</p>

  <p><b>What you see:</b><br>
  In the Profile GPU Rendering graph, orange bar segments may be tall,
  because the CPU is waiting for the GPU to finish all this work. On our device, the screen will
  flash green while your app slows down. See
  <a href="http://www.curious-creature.com/2013/09/13/optimizing-hardware-layers/">
  Optimizing Hardware Layers</a> for an example.</p>

  <p><b>Problem:</b><br>
  From a performance perspective, fade and transparency effects are expensive,
  because you have to draw every pixel and possibly whole parts of your view hierarchy multiple
  times.</p>

  <p><b>Solution:</b><br>
  You might be able to improve drawing performance by controlling how the
  renderer uses hardware layers and by using alpha rendering sparingly.</p>

  <p><b>Optimize your app:</b><br>
  Eliminate non-critical alpha rendering and use hardware layers
  effectively. Learn more on <a href=
  "https://www.youtube.com/watch?v=wIy8g8yNhNk">The Hidden Cost of Transparency</a>
  and <a href="http://developer.android.com/guide/topics/graphics/hardware-accel.html">
     Hardware Acceleration</a></p>

<!----------------------------->

  <h2>Large Uncompressed Bitmaps</h2>

  <p><b>What the user sees:</b><br>
  Intermittent drops in frame rate, and crashes in the worst
  case.</p>

  <p><b>Use these tools:</b><br>
  <a href="{@docRoot}tools/performance/memory-monitor/index.html">Memory Monitor</a>
   and <a href="{@docRoot}tools/performance/heap-viewer/index.html">Heap Viewer</a>.</p>

  <p><b>What you see:</b><br>
  In Heap Viewer, look for large bitmap
  objects. In Memory Monitor, you'll see an unhealthy number of garbage
  collection events.</p>

  <p><b>Problem:</b><br>
  Once loaded, your app's bitmaps are uncompressed, which
  not only uses up memory but also affects garbage collection.</p>

  <p><b>Solution:</b><br>
  You might be able to increase available memory, reduce garbage collection
  overhead, and increase rendering performance by using smaller bitmap pixel formats.</p>

  <p><b>Optimize your app:</b><br>
  Consider Smaller Pixel Formats. See <a href=
  "https://www.youtube.com/watch?v=1WqcEHXRWpM">Smaller Pixel Formats</a>.</p>

  <!----------------------------->

<h2>Dimension Bitmaps</h2>

  <p><b>What the user sees:</b><br>
  Intermittent drops in frame rate, and crashes in the worst
  case.</p>

  <p><b>Use these tools:</b><br>
  <a href="{@docRoot}tools/performance/memory-monitor/index.html">Memory Monitor</a>
   and <a href="{@docRoot}tools/performance/heap-viewer/index.html">Heap Viewer</a>.</p>

  <p><b>What you see:</b><br>
  In Heap Viewer, look for large bitmap objects. In Memory Monitor,
  you'll see and unhealthy number of garbage collection events.</p>

  <p><b>Problem:</b><br>
  If the bitmaps your app is loading are larger than what is being displayed on
  the screen, they unnecessarily use memory space.</p>

  <p><b>Solution:</b><br>
  You might be able to increase available memory and rendering performance be
  pre-scaling your bitmaps.</p>

  <p><b>Optimize your app:</b><br>
  Use <a href="https://www.youtube.com/watch?v=HY9aaXHx8yA">Pre-scaled Bitmaps.</a></p>

<!----------------------------->

  <h2>Large Number of Bitmap Objects</h2>

  <p><b>What the user sees:</b><br>
  Intermittent drops in frame rate, and crashes in the worst
  case.</p>

  <p><b>Use these tools:</b><br>
  <a href="{@docRoot}tools/performance/memory-monitor/index.html">Memory Monitor</a>
   and
   <a href="{@docRoot}tools/performance/allocation-tracker/index.html">Allocation Tracker</a>.</p>

  <p><b>What you see:</b><br>
  In Allocation Tracker, look for bitmap objects. In Memory Monitor, you
  may see an unhealthy number of garbage collection events.</p>

  <p><b>Problem:</b><br>
  Your app is loading a stream of bitmaps that are each only used for a short
  time.</p>

  <p><b>Solution:</b><br>
  You might be able to improve memory usage and rendering performance by using
  object pools to reuse existing bitmap objects, and be reusing and caching bitmaps and
  textures.</p>

  <p><b>Optimize your app:</b><br>
  <a href="https://www.youtube.com/watch?v=_ioFW3cyRV0&gt">Reuse Bitmaps</a>
  and consider using <a href="https://www.youtube.com/watch?v=bSOREVMEFnM">Object Pools</a>.
  Consider using the <a href="https://github.com/bumptech/glide">Glide Library</a>.

