package android.net.wifi;

import android.os.Parcel;
import android.os.Parcelable;

public class ScanInfo implements Parcelable {
    private final ScanResult mScanResult;

    private final long mBSSID;          // The BSSID of the best AP with an SSID matching the OSU
    private final int mRSSI;            // RSSI of the AP with BSSID
    private final String mSSID;         // The SSID to connect to for an OSU connection.
    private final String mName;
    private final String mServiceDescription;
    private final String mIconType;
    private final byte[] mIconData;
    private final int mOSUIdentity;

    public ScanInfo(ScanResult scanResult) {
        mScanResult = scanResult;

        mBSSID = -1;
        mRSSI = -1;
        mSSID = null;
        mName = null;
        mServiceDescription = null;
        mIconType = null;
        mIconData = null;
        mOSUIdentity = -1;
    }

    public ScanInfo(long BSSID, int rssi, String SSID, String name, String serviceDescription,
                    String iconType, byte[] iconData, int OSUIdentity) {
        mBSSID = BSSID;
        mRSSI = rssi;
        mSSID = SSID;
        mName = name;
        mServiceDescription = serviceDescription;
        mIconType = iconType;
        mIconData = iconData;
        mOSUIdentity = OSUIdentity;

        mScanResult = null;
    }

    /**
     * Get the scan result of this ScanInfo.
     * @return The ScanResult, if this ScanInfo contains a one. If the ScanInfo contains
     * OSU information getScanResult will return null.
     */
    public ScanResult getScanResult() {
        return mScanResult;
    }

    /**
     * OSU only: The BSSID of the AP who advertises the OSU SSID. This value is not guaranteed to
     * be correct; In the somewhat unlikely case that multiple APs advertise OSU SSIDs that matches
     * an OSU information element returned through ANQP and one of those is not related to an OSU
     * there is a (slight) risk that the BSSID is for a "spoof" OSU.
     * The matching algorithm that produces the ScanInfo objects makes a best effort to get the
     * matching right though and since it is (a) fair to assume that the OSU SSID resides on the
     * same AP as the one advertising the OSU information, and (b) BSSIDs for multi-SSID APs are
     * typically adjacent to each other, matching will prefer the BSSID closest to the advertising
     * APs BSSID if multiple SSIDs match.
     * @return The BSSID.
     */
    public long getBssid() {
        return mBSSID;
    }

    /**
     * OSU only.
     * @return The signal level of the AP associated with the BSSID from getBSSID.
     */
    public int getRssi() {
        return mRSSI;
    }

    /**
     * OSU only.
     * @return The SSID of the AP to which to associate to establish an OSU connection.
     */
    public String getSsid() {
        return mSSID;
    }

    /**
     * OSU only.
     * @return The name of the Service Provider of the OSU.
     */
    public String getName() {
        return mName;
    }

    /**
     * OSU only.
     * @return The service description of the OSU.
     */
    public String getServiceDescription() {
        return mServiceDescription;
    }

    /**
     * OSU only.
     * Get the type of icon that icon data represents, e.g. JPG, PNG etc. This field is formatted
     * using standard MIME encodings per RFC-4288 and IANA MIME media types.
     * @return The icon type in icon data.
     */
    public String getIconType() {
        return mIconType;
    }

    /**
     * OSU only.
     * @return The binary data of the icon.
     */
    public byte[] getIconData() {
        return mIconData;
    }

    /**
     * OSU only.
     * @return a unique identity for the OSU. This value is generated by the framework and should
     * be used to uniquely identify a specific OSU. Please note that values may be reused after
     * a very long time-span (in any normal scenario, likely years) and implementations should make
     * sure to not rely on any long term persisted values.
     */
    public int getOsuIdentity() {
        return mOSUIdentity;
    }

    private static final int ScanResultMarker = 0;
    private static final int OSUMarker = 1;

    @Override
    public int describeContents() {
        return 0;
    }

    /** Implement the Parcelable interface {@hide} */
    public static final Creator<ScanInfo> CREATOR =
            new Creator<ScanInfo>() {
                @Override
                public ScanInfo createFromParcel(Parcel source) {
                    int marker = source.readInt();
                    if (marker == ScanResultMarker) {
                        return new ScanInfo(ScanResult.CREATOR.createFromParcel(source));
                    }
                    else if (marker == OSUMarker) {
                        return new ScanInfo(
                                source.readLong(),
                                source.readInt(),
                                source.readString(),
                                source.readString(),
                                source.readString(),
                                source.readString(),
                                source.createByteArray(),
                                source.readInt()
                                );
                    }
                    else {
                        throw new RuntimeException("Bad ScanInfo data");
                    }
                }

                @Override
                public ScanInfo[] newArray(int size) {
                    return new ScanInfo[0];
                }
            };

    @Override
    public void writeToParcel(Parcel dest, int flags) {
        if (mScanResult != null) {
            dest.writeInt(ScanResultMarker);
            mScanResult.writeToParcel(dest, flags);
            return;
        }

        dest.writeInt(OSUMarker);
        dest.writeLong(mBSSID);
        dest.writeInt(mRSSI);
        dest.writeString(mSSID);
        dest.writeString(mName);
        dest.writeString(mServiceDescription);
        dest.writeString(mIconType);
        dest.writeByteArray(mIconData);
        dest.writeInt(mOSUIdentity);
    }
}
